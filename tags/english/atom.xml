<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
	<title>meven&#x27;s blog - english</title>
	<link href="https://meven.github.io/tags/english/atom.xml" rel="self" type="application/atom+xml"/>
	<link href="https://meven.github.io"/>
	<generator uri="https://www.getzola.org/">Zola</generator>
	<updated>2017-01-08T00:00:00+00:00</updated>
	<id>https://meven.github.io/tags/english/atom.xml</id>
	<entry xml:lang="en">
		<title>Yet another sudoku solver, in rust</title>
		<published>2017-01-08T00:00:00+00:00</published>
		<updated>2017-01-08T00:00:00+00:00</updated>
		<link href="https://meven.github.io/yet-another-sudoku-solver-this-time-in-rust/" type="text/html"/>
		<id>https://meven.github.io/yet-another-sudoku-solver-this-time-in-rust/</id>
		<content type="html">&lt;p&gt;I have been quite interested recently with the new languages &lt;a href=&quot;https:&#x2F;&#x2F;golang.org&#x2F;&quot;&gt;Go&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;www.rust-lang.org&#x2F;&quot;&gt;rust&lt;&#x2F;a&gt;.
Go and rust have some very nice new features and their design and tooling reflects the standards of this days.
So I have been hacking with go and rust.&lt;&#x2F;p&gt;
&lt;p&gt;I share this piece of rust code that solves sudoku, in the hope it will be useful to someone.
It is not very much optimized as the algorithm is naive, but the purpose of this code was to get more comfortable with rust.&lt;&#x2F;p&gt;
&lt;p&gt;&#x2F;&#x2F;&#x2F;&lt;&#x2F;p&gt;
&lt;p&gt;fn print_grid(g: [Option&lt;i32&gt;; 81]) {&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;let mut cnt = 0;
let mut line = 0;

for &amp;amp;x in g.iter() {

    cnt = cnt + 1;

    match x {
        Some(i) =&amp;gt; print!(&amp;quot;{}&amp;quot;, i),
        None =&amp;gt; print!(&amp;quot;_&amp;quot;),
    }

    if cnt == 9 {
        line = line + 1;
        println!(&amp;quot;&amp;quot;);
        cnt = 0;
        if line == 3 {
            line = 0;
            println!(&amp;quot;&amp;quot;);
        }
    } else if cnt % 3 == 0 {
        print!(&amp;quot;   &amp;quot;);

    } else {
        print!(&amp;quot; &amp;quot;);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;}&lt;&#x2F;p&gt;
&lt;p&gt;fn check_grid(g: [Option&lt;i32&gt;; 81]) -&amp;gt; bool {&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;&#x2F;&#x2F; check lines
for x in 0..9 {
    let i = 9 * x;
    let val = [i, i + 1, i + 2, i + 3, i + 4, i + 5, i + 6, i + 7, i + 8];

    for v in 0..(val.len() - 1) {
        let valv = g[val[v]];
        if valv != None {
            for c in 1..val.len() {
                let valc = g[val[c]];
                if valc != None &amp;amp;&amp;amp; val[v] != val[c] &amp;amp;&amp;amp; valv == valc {
                    &#x2F;&#x2F; println!(&amp;quot;Block false at {}&amp;quot;, x);
                    return false;
                }
            }
        }
    }
}

&#x2F;&#x2F; check columns
for x in 0..9 {
    let val = [x, x + 9, x + 18, x + 27, x + 36, x + 45, x + 54, x + 63, x + 72];

    for v in 0..(val.len() - 1) {
        let valv = g[val[v]];
        if valv != None {
            for c in 1..val.len() {
                let valc = g[val[c]];
                if valc != None &amp;amp;&amp;amp; val[v] != val[c] &amp;amp;&amp;amp; valv == valc {
                    &#x2F;&#x2F; println!(&amp;quot;Block false at {}&amp;quot;, x);
                    return false;
                }
            }
        }
    }
}

&#x2F;&#x2F; check blocks
for x in 0..9 {
    let mut i = 3 * (x % 3);
    if x &amp;gt; 2 {
        i = i + 27;
    } else if x &amp;gt; 5 {
        i = i + 54;
    }

    let val = [i, i + 1, i + 2, i + 9, i + 10, i + 11, i + 18, i + 19, i + 20];

    for v in 0..(val.len() - 1) {
        let valv = g[val[v]];
        if valv != None {
            for c in 1..val.len() {
                let valc = g[val[c]];
                if valc != None &amp;amp;&amp;amp; val[v] != val[c] &amp;amp;&amp;amp; valv == valc {
                    &#x2F;&#x2F; println!(&amp;quot;Block false at {}&amp;quot;, x);
                    return false;
                }
            }
        }
    }
}

return true;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;}&lt;&#x2F;p&gt;
&lt;p&gt;fn is_grid_complete(g: [Option&lt;i32&gt;; 81]) -&amp;gt; bool {
let mut ret = true;
for &amp;amp;x in g.iter() {
match x {
Some(_) =&amp;gt; {}
None =&amp;gt; {
ret = false;
break;
}
}
}
return ret;
}&lt;&#x2F;p&gt;
&lt;p&gt;fn clone_grid(g: [Option&lt;i32&gt;; 81]) -&amp;gt; [Option&lt;i32&gt;; 81] {
let mut new_g: [Option&lt;i32&gt;; 81] = [None; 81];
for x in 0..g.len() {
new_g[x] = g[x];
}
return new_g;
}&lt;&#x2F;p&gt;
&lt;p&gt;fn solve_grid(g: [Option&lt;i32&gt;; 81]) -&amp;gt; Option&amp;lt;[Option&lt;i32&gt;; 81]&amp;gt; {&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;if is_grid_complete(g) {
    return Some(g);
}

for x in 0..g.len() {
    match g[x] {
        Some(_) =&amp;gt; {}
        None =&amp;gt; {

            let mut checked: [bool; 9] = [false; 9];

            for v in 1..10 {

                let mut new_g = clone_grid(g);
                new_g[x] = Some(v);

                checked[(v - 1) as usize] = true;

                if check_grid(new_g) {
                    match solve_grid(new_g) {
                        None =&amp;gt; {
                            if checked == [true; 9] {
                                &#x2F;&#x2F; the path is a dead end
                                return None;
                            } else {
                                continue;
                            }
                        }

                        Some(gx) =&amp;gt; return Some(gx),
                    }
                }
            }

            if checked == [true; 9] {
                &#x2F;&#x2F; Detected a dead end
                return None;
            }
        }
    }
}

return None;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;}&lt;&#x2F;p&gt;
&lt;p&gt;fn parse_grid(grid_string: &amp;amp;str) -&amp;gt; [Option&lt;i32&gt;; 81] {
let mut grid = [None; 81];&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;let mut i = 0;
for s in grid_string.split_whitespace() {
    match s {
        &amp;quot;_&amp;quot; =&amp;gt; {}
        val =&amp;gt; {
            grid[i] = Some(val.parse::&amp;lt;i32&amp;gt;().unwrap());
        }
    }
    i = i + 1;
}

return grid;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;}&lt;&#x2F;p&gt;
&lt;p&gt;fn main() {
let grid_string = r#&amp;quot;
1 _ _   _ _ _   _ _ 3
_ 4 _   _ _ 9   2 6 _
_ _ _   7 _ _   _ 5 4&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code&gt;        _ _ _   1 7 _   9 _ _
        _ _ 2   _ _ _   6 _ _
        _ _ 3   _ 9 5   _ _ _

        2 7 _   _ _ 1   _ _ _
        _ 8 9   3 _ _   _ 7 _
        6 _ _   _ _ _   _ _ 2&amp;quot;#;

let grid: [Option&amp;lt;i32&amp;gt;; 81] = parse_grid(grid_string);

print_grid(grid);

match solve_grid(grid) {
    Some(g) =&amp;gt; {
        println!(&amp;quot;Grid complete !&amp;quot;);
        print_grid(g)
    }
    None =&amp;gt; println!(&amp;quot;Couldn&#x27;t solve the sudoku&amp;quot;),
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;}&lt;&#x2F;p&gt;
&lt;p&gt;&#x2F;&#x2F;&#x2F;&lt;&#x2F;p&gt;
&lt;p&gt;You can just, given you have installed &lt;a href=&quot;https:&#x2F;&#x2F;www.rustup.rs&#x2F;&quot;&gt;rust&lt;&#x2F;a&gt;.
&#x2F;&#x2F;&#x2F;
cargo build
&#x2F;&#x2F;&#x2F;&lt;&#x2F;p&gt;
</content>
	</entry>
</feed>
