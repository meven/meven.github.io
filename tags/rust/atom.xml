<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title>meven&#x27;s blog - rust</title>
    <link rel="self" type="application/atom+xml" href="https://meven.github.io/tags/rust/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://meven.github.io"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2020-06-30T00:00:00+00:00</updated>
    <id>https://meven.github.io/tags/rust/atom.xml</id>
    <entry xml:lang="en">
        <title>New Static blog</title>
        <published>2020-06-30T00:00:00+00:00</published>
        <updated>2020-06-30T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://meven.github.io/new-static-blog/"/>
        <id>https://meven.github.io/new-static-blog/</id>
        
        <content type="html" xml:base="https://meven.github.io/new-static-blog/">&lt;p&gt;My blog hosting platform was maintained by my domain name provider &lt;a href=&quot;https:&#x2F;&#x2F;www.gandi.net&#x2F;&quot;&gt;gandi&lt;&#x2F;a&gt;.
It used the &lt;a href=&quot;https:&#x2F;&#x2F;dotclear.org&#x2F;&quot;&gt;dotclear&lt;&#x2F;a&gt; blog CMS.
But gandi has decided to stop maintaining this service at the end of June 2020.&lt;&#x2F;p&gt;
&lt;p&gt;It has served me well over the years but the lack of proper maintenance and support was showing.&lt;&#x2F;p&gt;
&lt;p&gt;As I am very fond of &lt;a href=&quot;https:&#x2F;&#x2F;www.rust-lang.org&#x2F;&quot;&gt;Rust&lt;&#x2F;a&gt;, I have written a small Rust program to convert the export of the blog to markdown files, using &lt;a href=&quot;https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;csv&quot;&gt;csv&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;regex&quot;&gt;regex&lt;&#x2F;a&gt; crates.&lt;&#x2F;p&gt;
&lt;p&gt;I have switched to the &lt;a href=&quot;https:&#x2F;&#x2F;www.getzola.org&#x2F;&quot;&gt;zola static site generator&lt;&#x2F;a&gt; hosted by &lt;a href=&quot;https:&#x2F;&#x2F;pages.github.com&#x2F;&quot;&gt;github pages&lt;&#x2F;a&gt;.
The good thing is now my blog posts are written in markdown, and I gained a search tool.&lt;&#x2F;p&gt;
&lt;p&gt;Unfortunately all my entrant links will be broken, but all the content is there at least.&lt;&#x2F;p&gt;
&lt;p&gt;And as a souvenir, here is what my old blog looked like, with photos taken in Australia in the header :&lt;&#x2F;p&gt;
&lt;img src=&quot;&#x2F;captures&#x2F;old_blog_06.2020.png&quot; alt=&quot;Old blog look&quot;&#x2F;&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Yet another sudoku solver, in rust</title>
        <published>2017-01-08T00:00:00+00:00</published>
        <updated>2017-01-08T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://meven.github.io/yet-another-sudoku-solver-this-time-in-rust/"/>
        <id>https://meven.github.io/yet-another-sudoku-solver-this-time-in-rust/</id>
        
        <content type="html" xml:base="https://meven.github.io/yet-another-sudoku-solver-this-time-in-rust/">&lt;p&gt;I have been quite interested recently with the new languages &lt;a href=&quot;https:&#x2F;&#x2F;golang.org&#x2F;&quot;&gt;Go&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;www.rust-lang.org&#x2F;&quot;&gt;rust&lt;&#x2F;a&gt;.
Go and rust have some very nice new features and their design and tooling reflects the standards of this days.
So I have been hacking with go and rust.&lt;&#x2F;p&gt;
&lt;p&gt;I share this piece of rust code that solves sudoku, in the hope it will be useful to someone.
It is not very much optimized as the algorithm is naive, but the purpose of this code was to get more comfortable with rust.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;
fn print_grid(g: [Option&amp;lt;i32&amp;gt;; 81]) {

    let mut cnt = 0;
    let mut line = 0;

    for &amp;amp;x in g.iter() {

        cnt = cnt + 1;

        match x {
            Some(i) =&amp;gt; print!(&amp;quot;{}&amp;quot;, i),
            None =&amp;gt; print!(&amp;quot;_&amp;quot;),
        }

        if cnt == 9 {
            line = line + 1;
            println!(&amp;quot;&amp;quot;);
            cnt = 0;
            if line == 3 {
                line = 0;
                println!(&amp;quot;&amp;quot;);
            }
        } else if cnt % 3 == 0 {
            print!(&amp;quot;   &amp;quot;);

        } else {
            print!(&amp;quot; &amp;quot;);
        }
    }
}

fn check_grid(g: [Option&amp;lt;i32&amp;gt;; 81]) -&amp;gt; bool {

    &amp;#x2F;&amp;#x2F; check lines
    for x in 0..9 {
        let i = 9 * x;
        let val = [i, i + 1, i + 2, i + 3, i + 4, i + 5, i + 6, i + 7, i + 8];

        for v in 0..(val.len() - 1) {
            let valv = g[val[v]];
            if valv != None {
                for c in 1..val.len() {
                    let valc = g[val[c]];
                    if valc != None &amp;amp;&amp;amp; val[v] != val[c] &amp;amp;&amp;amp; valv == valc {
                        &amp;#x2F;&amp;#x2F; println!(&amp;quot;Block false at {}&amp;quot;, x);
                        return false;
                    }
                }
            }
        }
    }

    &amp;#x2F;&amp;#x2F; check columns
    for x in 0..9 {
        let val = [x, x + 9, x + 18, x + 27, x + 36, x + 45, x + 54, x + 63, x + 72];

        for v in 0..(val.len() - 1) {
            let valv = g[val[v]];
            if valv != None {
                for c in 1..val.len() {
                    let valc = g[val[c]];
                    if valc != None &amp;amp;&amp;amp; val[v] != val[c] &amp;amp;&amp;amp; valv == valc {
                        &amp;#x2F;&amp;#x2F; println!(&amp;quot;Block false at {}&amp;quot;, x);
                        return false;
                    }
                }
            }
        }
    }

    &amp;#x2F;&amp;#x2F; check blocks
    for x in 0..9 {
        let mut i = 3 * (x % 3);
        if x &amp;gt; 2 {
            i = i + 27;
        } else if x &amp;gt; 5 {
            i = i + 54;
        }

        let val = [i, i + 1, i + 2, i + 9, i + 10, i + 11, i + 18, i + 19, i + 20];

        for v in 0..(val.len() - 1) {
            let valv = g[val[v]];
            if valv != None {
                for c in 1..val.len() {
                    let valc = g[val[c]];
                    if valc != None &amp;amp;&amp;amp; val[v] != val[c] &amp;amp;&amp;amp; valv == valc {
                        &amp;#x2F;&amp;#x2F; println!(&amp;quot;Block false at {}&amp;quot;, x);
                        return false;
                    }
                }
            }
        }
    }

    return true;
}

fn is_grid_complete(g: [Option&amp;lt;i32&amp;gt;; 81]) -&amp;gt; bool {
    let mut ret = true;
    for &amp;amp;x in g.iter() {
        match x {
            Some(_) =&amp;gt; {}
            None =&amp;gt; {
                ret = false;
                break;
            }
        }
    }
    return ret;
}

fn clone_grid(g: [Option&amp;lt;i32&amp;gt;; 81]) -&amp;gt; [Option&amp;lt;i32&amp;gt;; 81] {
    let mut new_g: [Option&amp;lt;i32&amp;gt;; 81] = [None; 81];
    for x in 0..g.len() {
        new_g[x] = g[x];
    }
    return new_g;
}


fn solve_grid(g: [Option&amp;lt;i32&amp;gt;; 81]) -&amp;gt; Option&amp;lt;[Option&amp;lt;i32&amp;gt;; 81]&amp;gt; {

    if is_grid_complete(g) {
        return Some(g);
    }

    for x in 0..g.len() {
        match g[x] {
            Some(_) =&amp;gt; {}
            None =&amp;gt; {

                let mut checked: [bool; 9] = [false; 9];

                for v in 1..10 {

                    let mut new_g = clone_grid(g);
                    new_g[x] = Some(v);

                    checked[(v - 1) as usize] = true;

                    if check_grid(new_g) {
                        match solve_grid(new_g) {
                            None =&amp;gt; {
                                if checked == [true; 9] {
                                    &amp;#x2F;&amp;#x2F; the path is a dead end
                                    return None;
                                } else {
                                    continue;
                                }
                            }

                            Some(gx) =&amp;gt; return Some(gx),
                        }
                    }
                }

                if checked == [true; 9] {
                    &amp;#x2F;&amp;#x2F; Detected a dead end
                    return None;
                }
            }
        }
    }

    return None;
}

fn parse_grid(grid_string: &amp;amp;str) -&amp;gt; [Option&amp;lt;i32&amp;gt;; 81] {
    let mut grid = [None; 81];

    let mut i = 0;
    for s in grid_string.split_whitespace() {
        match s {
            &amp;quot;_&amp;quot; =&amp;gt; {}
            val =&amp;gt; {
                grid[i] = Some(val.parse::&amp;lt;i32&amp;gt;().unwrap());
            }
        }
        i = i + 1;
    }

    return grid;
}

fn main() {
    let grid_string = r#&amp;quot;
            1 _ _   _ _ _   _ _ 3
            _ 4 _   _ _ 9   2 6 _
            _ _ _   7 _ _   _ 5 4

            _ _ _   1 7 _   9 _ _
            _ _ 2   _ _ _   6 _ _
            _ _ 3   _ 9 5   _ _ _

            2 7 _   _ _ 1   _ _ _
            _ 8 9   3 _ _   _ 7 _
            6 _ _   _ _ _   _ _ 2&amp;quot;#;

    let grid: [Option&amp;lt;i32&amp;gt;; 81] = parse_grid(grid_string);

    print_grid(grid);

    match solve_grid(grid) {
        Some(g) =&amp;gt; {
            println!(&amp;quot;Grid complete !&amp;quot;);
            print_grid(g)
        }
        None =&amp;gt; println!(&amp;quot;Couldn&amp;#x27;t solve the sudoku&amp;quot;),
    }

}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;You can just, given you have installed &lt;a href=&quot;https:&#x2F;&#x2F;www.rustup.rs&#x2F;&quot;&gt;rust&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;cargo build
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</content>
        
    </entry>
</feed>
